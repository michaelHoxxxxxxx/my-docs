# SoulBox SurrealDB é›†æˆæŒ‡å—

> SoulBox AI ä»£ç æ‰§è¡Œæ²™ç®± SurrealDB ä¸»æ•°æ®åº“è§£å†³æ–¹æ¡ˆå…¨é¢é›†æˆæŒ‡å—

## ğŸ¯ ä¸ºä»€ä¹ˆé€‰æ‹© SurrealDB ä½œä¸º SoulBox æ•°æ®åº“

SurrealDB è¢«é€‰ä¸º SoulBox çš„ä¸»è¦æ•°æ®åº“è§£å†³æ–¹æ¡ˆã€‚è¿™ä¸ªå†³å®šæ˜¯åŸºäºå‡ ä¸ªä¸ AI ä»£ç æ‰§è¡Œæ²™ç®±å¹³å°è¦æ±‚å®Œç¾å¥‘åˆçš„å…³é”®ä¼˜åŠ¿ã€‚

### æ ¸å¿ƒä¼˜åŠ¿

#### 1. **å¤šæ¨¡å‹æ•°æ®åº“èƒ½åŠ›**
- **æ–‡æ¡£å­˜å‚¨**ï¼šä»¥çµæ´»çš„ JSON æ–‡æ¡£å½¢å¼å­˜å‚¨å¤æ‚çš„æ‰§è¡Œå…ƒæ•°æ®ã€ç”¨æˆ·ä¼šè¯å’Œé…ç½®æ•°æ®
- **å›¾å…³ç³»**ï¼šå»ºæ¨¡ç”¨æˆ·ã€æ²™ç®±ã€æ‰§è¡Œå’Œè®¡è´¹æ•°æ®ä¹‹é—´çš„å¤æ‚å…³ç³»
- **æ—¶é—´åºåˆ—**ï¼šåŸç”Ÿæ”¯æŒæ‰§è¡Œæ—¥å¿—ã€æŒ‡æ ‡å’Œè®¡è´¹äº‹ä»¶çš„æ—¶é—´æŸ¥è¯¢
- **é”®å€¼**ï¼šä¼šè¯ç®¡ç†å’Œç¼“å­˜çš„å¿«é€Ÿè®¿é—®æ¨¡å¼

#### 2. **å®æ—¶åŠŸèƒ½**
- **å®æ—¶æŸ¥è¯¢**ï¼šå®æ—¶ç›‘æ§æ²™ç®±çŠ¶æ€ã€èµ„æºä½¿ç”¨å’Œæ‰§è¡Œè¿›åº¦
- **WebSocket é›†æˆ**ï¼šåŸç”Ÿæ”¯æŒä»ªè¡¨æ¿å’Œç›‘æ§ç•Œé¢çš„å®æ—¶æ›´æ–°
- **äº‹ä»¶æµ**ï¼šå†…ç½®å‘å¸ƒ/è®¢é˜…ç”¨äºæœåŠ¡é—´é€šä¿¡å’Œé€šçŸ¥

#### 3. **Rust åŸç”Ÿé›†æˆ**
- **é›¶æ‹·è´åºåˆ—åŒ–**ï¼šä½¿ç”¨åŸç”Ÿ Rust ç±»å‹çš„é«˜æ•ˆæ•°æ®å¤„ç†
- **Async/Await æ”¯æŒ**ï¼šä¸åŸºäº tokio çš„ SoulBox æ¶æ„æ— ç¼é›†æˆ
- **ç±»å‹å®‰å…¨**ï¼šè‡ªå®šä¹‰ç»“æ„ä½“å’Œæšä¸¾çš„å¼ºç±»å‹
- **æ€§èƒ½**ï¼šç›´æ¥ Rust SDK çš„æœ€å°å¼€é”€

#### 4. **ç®€åŒ–è¿ç»´**
- **å•ä¸€æ•°æ®åº“**ï¼šç»Ÿä¸€çš„æ•°æ®åº“è§£å†³æ–¹æ¡ˆï¼Œæ¶ˆé™¤å¤šç§æ•°æ®åº“æŠ€æœ¯çš„ç»´æŠ¤å¤æ‚æ€§
- **åµŒå…¥å¼æ¨¡å¼**ï¼šå¼€å‘/æµ‹è¯•ä½¿ç”¨ kv-rocksdb åµŒå…¥å¼å­˜å‚¨
- **åˆ†å¸ƒå¼æ¨¡å¼**ï¼šç”Ÿäº§ä½¿ç”¨ protocol-ws/http è¿œç¨‹éƒ¨ç½²
- **è¿è¡Œæ¨¡å¼çº¦æŸ**ï¼šå¼€å‘/æµ‹è¯•ä½¿ç”¨ kv-rocksdb åµŒå…¥å¼ï¼Œç”Ÿäº§ä½¿ç”¨ protocol-ws/http è¿œç¨‹éƒ¨ç½²ï¼›ä¸¤ç§æ¨¡å¼ä¸å¯åŒæ—¶å¯ç”¨ï¼Œé¿å…çŠ¶æ€åˆ†è£‚
- **æ¶æ„æ¼”è¿›**ï¼šæ— éœ€è¿ç§»çš„çµæ´»æ¶æ„å˜æ›´

## ğŸ—ï¸ SoulBox æ•°æ®åº“æ¶æ„è®¾è®¡

### æ ¸å¿ƒè¡¨å’Œç»“æ„

#### 1. ç”¨æˆ·ç®¡ç†

```sql
-- ç”¨æˆ·è¡¨ï¼Œç”¨äºè®¤è¯å’Œé…ç½®æ–‡ä»¶æ•°æ®
DEFINE TABLE users SCHEMAFULL;
DEFINE FIELD id ON users TYPE record<users>;
DEFINE FIELD email ON users TYPE string ASSERT string::is::email($value);
DEFINE FIELD username ON users TYPE string;
DEFINE FIELD password_hash ON users TYPE string;
DEFINE FIELD created_at ON users TYPE datetime DEFAULT time::now();
DEFINE FIELD last_login ON users TYPE datetime;
DEFINE FIELD subscription_tier ON users TYPE string DEFAULT "free";
DEFINE FIELD is_active ON users TYPE bool DEFAULT true;
DEFINE FIELD metadata ON users TYPE object;

-- ç”¨äºå¿«é€Ÿç”¨æˆ·æŸ¥æ‰¾çš„ç´¢å¼•
DEFINE INDEX idx_users_email ON users COLUMNS email UNIQUE;
DEFINE INDEX idx_users_username ON users COLUMNS username UNIQUE;
```

#### 2. æ²™ç®±ç®¡ç†

```sql
-- æ²™ç®±è¡¨ï¼Œç”¨äºç®¡ç†æ‰§è¡Œç¯å¢ƒ
DEFINE TABLE sandboxes SCHEMAFULL;
DEFINE FIELD id ON sandboxes TYPE record<sandboxes>;
DEFINE FIELD user_id ON sandboxes TYPE record<users>;
DEFINE FIELD name ON sandboxes TYPE string;
DEFINE FIELD language ON sandboxes TYPE string;
DEFINE FIELD status ON sandboxes TYPE string DEFAULT "created";
DEFINE FIELD container_id ON sandboxes TYPE string;
DEFINE FIELD created_at ON sandboxes TYPE datetime DEFAULT time::now();
DEFINE FIELD started_at ON sandboxes TYPE datetime;
DEFINE FIELD terminated_at ON sandboxes TYPE datetime;
DEFINE FIELD resource_limits ON sandboxes TYPE object;
DEFINE FIELD metadata ON sandboxes TYPE object;

-- ç”¨äºé«˜æ•ˆæŸ¥è¯¢çš„ç´¢å¼•
DEFINE INDEX idx_sandboxes_user ON sandboxes COLUMNS user_id;
DEFINE INDEX idx_sandboxes_status ON sandboxes COLUMNS status;
DEFINE INDEX idx_sandboxes_container ON sandboxes COLUMNS container_id;
```

#### 3. ä»£ç æ‰§è¡Œä¼šè¯

```sql
-- æ‰§è¡Œä¼šè¯ï¼Œç”¨äºè·Ÿè¸ªä»£ç è¿è¡Œ
DEFINE TABLE executions SCHEMAFULL;
DEFINE FIELD id ON executions TYPE record<executions>;
DEFINE FIELD sandbox_id ON executions TYPE record<sandboxes>;
DEFINE FIELD user_id ON executions TYPE record<users>;
DEFINE FIELD code ON executions TYPE string;
DEFINE FIELD language ON executions TYPE string;
DEFINE FIELD status ON executions TYPE string DEFAULT "queued";
DEFINE FIELD started_at ON executions TYPE datetime;
DEFINE FIELD completed_at ON executions TYPE datetime;
DEFINE FIELD duration_ms ON executions TYPE number;
DEFINE FIELD output ON executions TYPE object;
DEFINE FIELD error ON executions TYPE object;
DEFINE FIELD resource_usage ON executions TYPE object;
DEFINE FIELD billing_info ON executions TYPE object;

-- ç”¨äºåˆ†æå’Œè®¡è´¹çš„ç´¢å¼•
DEFINE INDEX idx_executions_user ON executions COLUMNS user_id;
DEFINE INDEX idx_executions_sandbox ON executions COLUMNS sandbox_id;
DEFINE INDEX idx_executions_status ON executions COLUMNS status;
DEFINE INDEX idx_executions_time ON executions COLUMNS started_at;
```

#### 4. èµ„æºç›‘æ§

```sql
-- ç”¨äºç›‘æ§å’Œè®¡è´¹çš„èµ„æºä½¿ç”¨æŒ‡æ ‡
DEFINE TABLE resource_metrics SCHEMAFULL;
DEFINE FIELD id ON resource_metrics TYPE record<resource_metrics>;
DEFINE FIELD sandbox_id ON resource_metrics TYPE record<sandboxes>;
DEFINE FIELD timestamp ON resource_metrics TYPE datetime DEFAULT time::now();
DEFINE FIELD cpu_usage ON resource_metrics TYPE number;
DEFINE FIELD memory_usage ON resource_metrics TYPE number;
DEFINE FIELD disk_usage ON resource_metrics TYPE number;
DEFINE FIELD network_usage ON resource_metrics TYPE object;
DEFINE FIELD custom_metrics ON resource_metrics TYPE object;

-- ç”¨äºé«˜æ•ˆèŒƒå›´æŸ¥è¯¢çš„æ—¶é—´åºåˆ—ç´¢å¼•
DEFINE INDEX idx_metrics_time ON resource_metrics COLUMNS timestamp;
DEFINE INDEX idx_metrics_sandbox_time ON resource_metrics COLUMNS sandbox_id, timestamp;
```

#### 5. è®¡è´¹å’Œä½¿ç”¨æƒ…å†µ

```sql
-- ç”¨äºä½¿ç”¨æƒ…å†µè·Ÿè¸ªçš„è®¡è´¹äº‹ä»¶
DEFINE TABLE billing_events SCHEMAFULL;
DEFINE FIELD id ON billing_events TYPE record<billing_events>;
DEFINE FIELD user_id ON billing_events TYPE record<users>;
DEFINE FIELD execution_id ON billing_events TYPE record<executions>;
DEFINE FIELD event_type ON billing_events TYPE string;
DEFINE FIELD timestamp ON billing_events TYPE datetime DEFAULT time::now();
DEFINE FIELD amount ON billing_events TYPE number;
DEFINE FIELD currency ON billing_events TYPE string DEFAULT "USD";
DEFINE FIELD metadata ON billing_events TYPE object;

-- æœˆåº¦ä½¿ç”¨æƒ…å†µæ±‡æ€»
DEFINE TABLE usage_aggregates SCHEMAFULL;
DEFINE FIELD id ON usage_aggregates TYPE record<usage_aggregates>;
DEFINE FIELD user_id ON usage_aggregates TYPE record<users>;
DEFINE FIELD period ON usage_aggregates TYPE string; -- "2024-01"
DEFINE FIELD total_executions ON usage_aggregates TYPE number DEFAULT 0;
DEFINE FIELD total_duration_ms ON usage_aggregates TYPE number DEFAULT 0;
DEFINE FIELD total_cost ON usage_aggregates TYPE number DEFAULT 0;
DEFINE FIELD breakdown ON usage_aggregates TYPE object;

-- è®¡è´¹ç´¢å¼•
DEFINE INDEX idx_billing_user_time ON billing_events COLUMNS user_id, timestamp;
DEFINE INDEX idx_usage_user_period ON usage_aggregates COLUMNS user_id, period UNIQUE;
```

### å›¾å…³ç³»

```sql
-- å®šä¹‰å®ä½“ä¹‹é—´çš„å…³ç³»
DEFINE TABLE user_sandbox SCHEMAFULL AS SELECT * FROM users->owns->sandbox;
DEFINE TABLE sandbox_execution SCHEMAFULL AS SELECT * FROM sandbox->runs->execution;
DEFINE TABLE execution_metrics SCHEMAFULL AS SELECT * FROM execution->generates->resource_metrics;

-- å…³ç³»è¡¨
DEFINE TABLE owns SCHEMAFULL;
DEFINE TABLE runs SCHEMAFULL;
DEFINE TABLE generates SCHEMAFULL;
```

## ğŸ”§ Rust é›†æˆå®ç°

### 1. Cargo ä¾èµ–

```toml
[dependencies]
# SurrealDB å®¢æˆ·ç«¯
surrealdb = { version = "1.5", features = ["protocol-ws", "protocol-http", "kv-rocksdb"] }
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
tokio = { version = "1.0", features = ["full"] }
uuid = { version = "1.0", features = ["v4", "serde"] }
chrono = { version = "0.4", features = ["serde"] }
anyhow = "1.0"
thiserror = "1.0"
```

### 2. æ•°æ®åº“è¿æ¥å’Œé…ç½®

```rust
use surrealdb::engine::remote::ws::{Client, Ws};
use surrealdb::opt::auth::Root;
use surrealdb::{Result, Surreal};
use std::sync::Arc;
use tokio::sync::RwLock;

#[derive(Clone)]
pub struct DatabaseManager {
    db: Arc<Surreal<Client>>,
    config: DatabaseConfig,
}

#[derive(Clone, Debug)]
pub struct DatabaseConfig {
    pub host: String,
    pub port: u16,
    pub namespace: String,
    pub database: String,
    pub username: String,
    pub password: String,
}

impl DatabaseManager {
    pub async fn new(config: DatabaseConfig) -> Result<Self> {
        // è¿æ¥åˆ° SurrealDB
        let db = Surreal::new::<Ws>(format!("{}:{}", config.host, config.port)).await?;

        // è®¤è¯
        db.signin(Root {
            username: &config.username,
            password: &config.password,
        }).await?;

        // é€‰æ‹©å‘½åç©ºé—´å’Œæ•°æ®åº“
        db.use_ns(&config.namespace).use_db(&config.database).await?;

        Ok(Self {
            db: Arc::new(db),
            config,
        })
    }

    pub fn get_connection(&self) -> Arc<Surreal<Client>> {
        Arc::clone(&self.db)
    }
}
```

### 3. æ•°æ®æ¨¡å‹å’Œç»“æ„ä½“

```rust
use serde::{Deserialize, Serialize};
use surrealdb::sql::Thing;
use chrono::{DateTime, Utc};
use uuid::Uuid;

// ç”¨æˆ·æ¨¡å‹
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct User {
    pub id: Option<Thing>,
    pub email: String,
    pub username: String,
    pub password_hash: String,
    pub created_at: DateTime<Utc>,
    pub last_login: Option<DateTime<Utc>>,
    pub subscription_tier: String,
    pub is_active: bool,
    pub metadata: serde_json::Value,
}

// æ²™ç®±æ¨¡å‹
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Sandbox {
    pub id: Option<Thing>,
    pub user_id: Thing,
    pub name: String,
    pub language: String,
    pub status: SandboxStatus,
    pub container_id: Option<String>,
    pub created_at: DateTime<Utc>,
    pub started_at: Option<DateTime<Utc>>,
    pub terminated_at: Option<DateTime<Utc>>,
    pub resource_limits: ResourceLimits,
    pub metadata: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum SandboxStatus {
    Created,
    Starting,
    Running,
    Stopped,
    Error,
    Terminated,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceLimits {
    pub max_memory_mb: u64,
    pub max_cpu_cores: f64,
    pub max_disk_mb: u64,
    pub max_execution_time_sec: u64,
}

// æ‰§è¡Œæ¨¡å‹
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Execution {
    pub id: Option<Thing>,
    pub sandbox_id: Thing,
    pub user_id: Thing,
    pub code: String,
    pub language: String,
    pub status: ExecutionStatus,
    pub started_at: Option<DateTime<Utc>>,
    pub completed_at: Option<DateTime<Utc>>,
    pub duration_ms: Option<u64>,
    pub output: Option<ExecutionOutput>,
    pub error: Option<ExecutionError>,
    pub resource_usage: Option<ResourceUsage>,
    pub billing_info: Option<BillingInfo>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ExecutionStatus {
    Queued,
    Running,
    Completed,
    Failed,
    Timeout,
    Cancelled,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionOutput {
    pub stdout: String,
    pub stderr: String,
    pub return_code: i32,
    pub files: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ExecutionError {
    pub error_type: String,
    pub message: String,
    pub stack_trace: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceUsage {
    pub peak_memory_mb: u64,
    pub cpu_time_ms: u64,
    pub disk_io_mb: u64,
    pub network_io_mb: u64,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct BillingInfo {
    pub compute_units: f64,
    pub cost_usd: f64,
    pub billing_tier: String,
}
```

### 4. ä»“åº“æ¨¡å¼å®ç°

```rust
use anyhow::Result;
use surrealdb::sql::Thing;

#[async_trait::async_trait]
pub trait UserRepository {
    async fn create_user(&self, user: &User) -> Result<User>;
    async fn get_user_by_id(&self, id: &Thing) -> Result<Option<User>>;
    async fn get_user_by_email(&self, email: &str) -> Result<Option<User>>;
    async fn update_user(&self, user: &User) -> Result<User>;
    async fn delete_user(&self, id: &Thing) -> Result<()>;
}

pub struct SurrealUserRepository {
    db: Arc<Surreal<Client>>,
}

impl SurrealUserRepository {
    pub fn new(db_manager: &DatabaseManager) -> Self {
        Self {
            db: db_manager.get_connection(),
        }
    }
}

#[async_trait::async_trait]
impl UserRepository for SurrealUserRepository {
    async fn create_user(&self, user: &User) -> Result<User> {
        let created: Option<User> = self.db
            .create("users")
            .content(user)
            .await?;
        
        created.ok_or_else(|| anyhow::anyhow!("Failed to create user"))
    }

    async fn get_user_by_id(&self, id: &Thing) -> Result<Option<User>> {
        let user: Option<User> = self.db.select(id).await?;
        Ok(user)
    }

    async fn get_user_by_email(&self, email: &str) -> Result<Option<User>> {
        let mut result = self.db
            .query("SELECT * FROM users WHERE email = $email LIMIT 1")
            .bind(("email", email))
            .await?;
        
        let users: Vec<User> = result.take(0)?;
        Ok(users.into_iter().next())
    }

    async fn update_user(&self, user: &User) -> Result<User> {
        let updated: Option<User> = self.db
            .update(user.id.as_ref().unwrap())
            .content(user)
            .await?;
        
        updated.ok_or_else(|| anyhow::anyhow!("Failed to update user"))
    }

    async fn delete_user(&self, id: &Thing) -> Result<()> {
        let _: Option<User> = self.db.delete(id).await?;
        Ok(())
    }
}
```

### 5. ä½¿ç”¨å®æ—¶æŸ¥è¯¢çš„å®æ—¶ç›‘æ§

```rust
use futures_util::StreamExt;
use surrealdb::opt::QueryResult;

pub struct RealtimeMonitor {
    db: Arc<Surreal<Client>>,
}

impl RealtimeMonitor {
    pub fn new(db_manager: &DatabaseManager) -> Self {
        Self {
            db: db_manager.get_connection(),
        }
    }

    // ç›‘æ§æ²™ç®±çŠ¶æ€å˜åŒ–
    pub async fn monitor_sandbox_status(&self, sandbox_id: &Thing) -> Result<()> {
        let mut stream = self.db
            .query("LIVE SELECT * FROM sandboxes WHERE id = $sandbox_id")
            .bind(("sandbox_id", sandbox_id))
            .await?
            .stream::<Sandbox>(0)?;

        while let Some(result) = stream.next().await {
            match result {
                Ok(notification) => {
                    println!("Sandbox status changed: {:?}", notification);
                    // å¤„ç†çŠ¶æ€å˜åŒ–ï¼ˆæ›´æ–° UIã€å‘é€é€šçŸ¥ç­‰ï¼‰
                }
                Err(e) => {
                    eprintln!("Error in live query: {}", e);
                }
            }
        }

        Ok(())
    }

    // å®æ—¶ç›‘æ§èµ„æºä½¿ç”¨æƒ…å†µ
    pub async fn monitor_resource_usage(&self, user_id: &Thing) -> Result<()> {
        let mut stream = self.db
            .query("LIVE SELECT * FROM resource_metrics WHERE sandbox_id IN (SELECT id FROM sandboxes WHERE user_id = $user_id)")
            .bind(("user_id", user_id))
            .await?
            .stream::<ResourceMetrics>(0)?;

        while let Some(result) = stream.next().await {
            match result {
                Ok(metrics) => {
                    // å¤„ç†å®æ—¶æŒ‡æ ‡
                    self.process_resource_metrics(metrics).await?;
                }
                Err(e) => {
                    eprintln!("Error monitoring resource usage: {}", e);
                }
            }
        }

        Ok(())
    }

    async fn process_resource_metrics(&self, metrics: ResourceMetrics) -> Result<()> {
        // æ£€æŸ¥èµ„æºé™åˆ¶
        if metrics.memory_usage > 90.0 {
            // å‘é€è­¦æŠ¥
            println!("High memory usage detected: {}%", metrics.memory_usage);
        }

        // æ›´æ–°èšåˆæŒ‡æ ‡
        // è§¦å‘æ‰©å±•å†³ç­–
        // æ›´æ–°è®¡è´¹è®¡ç®—

        Ok(())
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ResourceMetrics {
    pub id: Option<Thing>,
    pub sandbox_id: Thing,
    pub timestamp: DateTime<Utc>,
    pub cpu_usage: f64,
    pub memory_usage: f64,
    pub disk_usage: f64,
    pub network_usage: NetworkUsage,
    pub custom_metrics: serde_json::Value,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct NetworkUsage {
    pub bytes_in: u64,
    pub bytes_out: u64,
    pub packets_in: u64,
    pub packets_out: u64,
}
```

## ğŸ“Š æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. ç´¢å¼•ç­–ç•¥

```sql
-- æ€§èƒ½å…³é”®ç´¢å¼•
DEFINE INDEX idx_executions_user_time ON executions COLUMNS user_id, started_at;
DEFINE INDEX idx_metrics_sandbox_recent ON resource_metrics COLUMNS sandbox_id, timestamp WHERE timestamp > time::now() - 1h;
DEFINE INDEX idx_billing_monthly ON billing_events COLUMNS user_id, timestamp WHERE timestamp > time::now() - 30d;

-- ä»£ç å’Œæ—¥å¿—çš„å…¨æ–‡æœç´¢
DEFINE ANALYZER code_analyzer TOKENIZERS class FILTERS lowercase, snowball(english);
DEFINE INDEX idx_executions_code_search ON executions COLUMNS code SEARCH ANALYZER code_analyzer BM25;
```

### 2. æŸ¥è¯¢ä¼˜åŒ–

```rust
impl SandboxRepository {
    // ä»ªè¡¨æ¿æ•°æ®çš„ä¼˜åŒ–æŸ¥è¯¢
    pub async fn get_user_dashboard_data(&self, user_id: &Thing) -> Result<DashboardData> {
        let query = "
            LET $user_sandboxes = (SELECT * FROM sandboxes WHERE user_id = $user_id AND status IN ['running', 'created']);
            LET $recent_executions = (SELECT * FROM executions WHERE user_id = $user_id AND started_at > time::now() - 24h ORDER BY started_at DESC LIMIT 10);
            LET $usage_today = (SELECT count() as total, sum(duration_ms) as total_duration FROM executions WHERE user_id = $user_id AND started_at > time::now() - 24h);
            
            SELECT {
                sandboxes: $user_sandboxes,
                recent_executions: $recent_executions,
                usage_today: $usage_today
            };
        ";

        let mut result = self.db
            .query(query)
            .bind(("user_id", user_id))
            .await?;

        let dashboard_data: DashboardData = result.take(0)?;
        Ok(dashboard_data)
    }

    // é«˜æ•ˆçš„èµ„æºä½¿ç”¨æƒ…å†µèšåˆ
    pub async fn get_resource_usage_summary(&self, sandbox_id: &Thing, duration: Duration) -> Result<ResourceSummary> {
        let query = "
            SELECT 
                math::mean(cpu_usage) as avg_cpu,
                math::max(cpu_usage) as peak_cpu,
                math::mean(memory_usage) as avg_memory,
                math::max(memory_usage) as peak_memory,
                count() as data_points
            FROM resource_metrics 
            WHERE sandbox_id = $sandbox_id 
            AND timestamp > time::now() - $duration
            GROUP ALL;
        ";

        let mut result = self.db
            .query(query)
            .bind(("sandbox_id", sandbox_id))
            .bind(("duration", duration.as_secs()))
            .await?;

        let summary: ResourceSummary = result.take(0)?;
        Ok(summary)
    }
}
```

### 3. è¿æ¥æ± å’Œç¼“å­˜

```rust
use std::collections::HashMap;
use tokio::sync::Mutex;

pub struct OptimizedDatabaseManager {
    primary_db: Arc<Surreal<Client>>,
    read_replicas: Vec<Arc<Surreal<Client>>>,
    cache: Arc<Mutex<HashMap<String, (DateTime<Utc>, serde_json::Value)>>>,
    cache_ttl: Duration,
}

impl OptimizedDatabaseManager {
    pub async fn new(config: DatabaseConfig) -> Result<Self> {
        // åˆ›å»ºä¸»è¿æ¥
        let primary_db = Self::create_connection(&config).await?;

        // åˆ›å»ºåªè¯»å‰¯æœ¬è¿æ¥
        let mut read_replicas = Vec::new();
        for _ in 0..config.read_replica_count {
            let replica = Self::create_connection(&config).await?;
            read_replicas.push(Arc::new(replica));
        }

        Ok(Self {
            primary_db: Arc::new(primary_db),
            read_replicas,
            cache: Arc::new(Mutex::new(HashMap::new())),
            cache_ttl: Duration::from_secs(300), // 5 minutes
        })
    }

    // è´Ÿè½½å‡è¡¡çš„è¯»å–æ“ä½œ
    pub fn get_read_connection(&self) -> Arc<Surreal<Client>> {
        if self.read_replicas.is_empty() {
            return Arc::clone(&self.primary_db);
        }

        let index = fastrand::usize(..self.read_replicas.len());
        Arc::clone(&self.read_replicas[index])
    }

    // å†™æ“ä½œå§‹ç»ˆä½¿ç”¨ä¸»åº“
    pub fn get_write_connection(&self) -> Arc<Surreal<Client>> {
        Arc::clone(&self.primary_db)
    }

    // å¸¦ TTL çš„ç¼“å­˜è¯»å–
    pub async fn cached_query<T>(&self, cache_key: String, query: &str) -> Result<T>
    where
        T: serde::de::DeserializeOwned + serde::Serialize,
    {
        // é¦–å…ˆæ£€æŸ¥ç¼“å­˜
        {
            let cache = self.cache.lock().await;
            if let Some((timestamp, value)) = cache.get(&cache_key) {
                if Utc::now().signed_duration_since(*timestamp) < chrono::Duration::from_std(self.cache_ttl)? {
                    return Ok(serde_json::from_value(value.clone())?);
                }
            }
        }

        // æ‰§è¡ŒæŸ¥è¯¢
        let db = self.get_read_connection();
        let mut result = db.query(query).await?;
        let data: T = result.take(0)?;

        // æ›´æ–°ç¼“å­˜
        {
            let mut cache = self.cache.lock().await;
            cache.insert(cache_key, (Utc::now(), serde_json::to_value(&data)?));
        }

        Ok(data)
    }
}
```


## ğŸ” å¤šç§Ÿæˆ·å’Œå®‰å…¨é…ç½®

### 1. å‘½åç©ºé—´å’Œæ•°æ®åº“ç»„ç»‡

```sql
-- å¤šç§Ÿæˆ·å‘½åç©ºé—´çš„ç”Ÿäº§é…ç½®

-- æ¯ä¸ªå®¢æˆ·/ç»„ç»‡çš„å‘½åç©ºé—´
DEFINE NAMESPACE customer_org_123;
USE NS customer_org_123;

-- ä¸åŒç¯å¢ƒçš„å•ç‹¬æ•°æ®åº“
DEFINE DATABASE production;
DEFINE DATABASE staging;
DEFINE DATABASE development;

-- ä½¿ç”¨ç”Ÿäº§æ•°æ®åº“
USE DB production;

-- å®šä¹‰è®¿é—®æ§åˆ¶
DEFINE ACCESS customer_access ON DATABASE TYPE RECORD
SIGNIN (
    SELECT * FROM users WHERE email = $email AND crypto::argon2::compare(password_hash, $password)
)
SIGNUP (
    CREATE user SET email = $email, password_hash = crypto::argon2::generate($password)
);

-- å®šä¹‰ç”¨æˆ·èŒƒå›´å’Œæƒé™
DEFINE SCOPE user_scope
SESSION 24h
SIGNUP (
    CREATE user SET 
        email = $email, 
        password_hash = crypto::argon2::generate($password),
        created_at = time::now(),
        subscription_tier = "free"
)
SIGNIN (
    SELECT * FROM users WHERE email = $email AND crypto::argon2::compare(password_hash, $password)
);

-- é˜²æ­¢ç”¨æˆ·è®¿é—®å…¶ä»–ç”¨æˆ·çš„æ•°æ®ï¼ˆåˆ›å»ºæ—¶å¿…é¡»æºå¸¦ user_id == $auth.idï¼‰
DEFINE FIELD user_id ON TABLE sandboxes PERMISSIONS 
    FOR select WHERE user_id = $auth.id
    FOR create WHERE $value = $auth.id
    FOR update WHERE user_id = $auth.id
    FOR delete WHERE user_id = $auth.id;
```

### 2. åŠ å¯†å’Œæ•°æ®ä¿æŠ¤

```rust
use aes_gcm::{Aes256Gcm, Key, Nonce};
use aes_gcm::aead::{Aead, NewAead};

pub struct EncryptedFieldManager {
    cipher: Aes256Gcm,
}

impl EncryptedFieldManager {
    pub fn new(key: &[u8; 32]) -> Self {
        let key = Key::from_slice(key);
        let cipher = Aes256Gcm::new(key);
        Self { cipher }
    }

    pub fn encrypt_sensitive_data(&self, data: &str) -> Result<String> {
        let nonce = Nonce::from_slice(b"unique nonce"); // Use proper nonce generation
        let ciphertext = self.cipher.encrypt(nonce, data.as_bytes())?;
        Ok(base64::encode(ciphertext))
    }

    pub fn decrypt_sensitive_data(&self, encrypted_data: &str) -> Result<String> {
        let nonce = Nonce::from_slice(b"unique nonce");
        let ciphertext = base64::decode(encrypted_data)?;
        let plaintext = self.cipher.decrypt(nonce, ciphertext.as_ref())?;
        Ok(String::from_utf8(plaintext)?)
    }
}

// åœ¨ç”¨æˆ·åˆ›å»ºä¸­çš„ä½¿ç”¨
impl SecureUserRepository {
    pub async fn create_user_with_encryption(&self, user: &User) -> Result<User> {
        let mut encrypted_user = user.clone();
        
        // åŠ å¯†æ•æ„Ÿå­—æ®µ
        if let Some(pii_data) = user.metadata.get("pii") {
            let encrypted_pii = self.encryption_manager
                .encrypt_sensitive_data(&pii_data.to_string())?;
            encrypted_user.metadata["pii"] = serde_json::Value::String(encrypted_pii);
        }

        self.user_repo.create_user(&encrypted_user).await
    }
}
```

### 3. å®¡è®¡æ—¥å¿—å’Œåˆè§„

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AuditLog {
    pub id: Option<Thing>,
    pub user_id: Option<Thing>,
    pub action: String,
    pub resource_type: String,
    pub resource_id: Option<String>,
    pub timestamp: DateTime<Utc>,
    pub ip_address: Option<String>,
    pub user_agent: Option<String>,
    pub success: bool,
    pub error_message: Option<String>,
    pub metadata: serde_json::Value,
}

pub struct AuditLogger {
    db: Arc<Surreal<Client>>,
}

impl AuditLogger {
    pub async fn log_action(&self, audit_log: AuditLog) -> Result<()> {
        let _: Option<AuditLog> = self.db
            .create("audit_logs")
            .content(&audit_log)
            .await?;
        
        Ok(())
    }

    pub async fn log_user_action(
        &self,
        user_id: &Thing,
        action: &str,
        resource_type: &str,
        ip_address: Option<String>,
    ) -> Result<()> {
        let audit_log = AuditLog {
            id: None,
            user_id: Some(user_id.clone()),
            action: action.to_string(),
            resource_type: resource_type.to_string(),
            resource_id: None,
            timestamp: Utc::now(),
            ip_address,
            user_agent: None,
            success: true,
            error_message: None,
            metadata: serde_json::Value::Null,
        };

        self.log_action(audit_log).await
    }
}

// è‡ªåŠ¨å®¡è®¡æ—¥å¿—çš„ä¸­é—´ä»¶
#[derive(Clone)]
pub struct AuditMiddleware {
    audit_logger: Arc<AuditLogger>,
}

impl AuditMiddleware {
    pub async fn log_request(&self, req: &HttpRequest, user_id: Option<Thing>) -> Result<()> {
        let action = format!("{} {}", req.method(), req.path());
        let ip_address = req.peer_addr().map(|addr| addr.ip().to_string());

        if let Some(user_id) = user_id {
            self.audit_logger.log_user_action(
                &user_id,
                &action,
                "http_request",
                ip_address,
            ).await?;
        }

        Ok(())
    }
}
```

## ğŸ“ˆ é…ç½®ç¤ºä¾‹

### 1. å¼€å‘é…ç½®

```toml
# config/development.toml
[database]
host = "127.0.0.1"
port = 8000
namespace = "soulbox_dev"
database = "main"
username = "root"
password = "root"
connection_timeout = 30
query_timeout = 60

[cache]
enabled = false
ttl_seconds = 300

[security]
encryption_enabled = false
audit_logging = true

[performance]
read_replica_count = 0
connection_pool_size = 10
```

### 2. ç”Ÿäº§é…ç½®

```toml
# config/production.toml
[database]
host = "surrealdb-cluster.example.com"
port = 8000
namespace = "soulbox_prod"
database = "main"
username = "${DB_USERNAME}"
password = "${DB_PASSWORD}"
connection_timeout = 10
query_timeout = 30

[cluster]
enabled = true
nodes = [
    "node1.surrealdb.example.com:8000",
    "node2.surrealdb.example.com:8000",
    "node3.surrealdb.example.com:8000"
]

[cache]
enabled = true
ttl_seconds = 600
redis_url = "${REDIS_URL}"

[security]
encryption_enabled = true
encryption_key = "${ENCRYPTION_KEY}"
audit_logging = true
jwt_secret = "${JWT_SECRET}"

# è®¤è¯æ¨¡å‹è¯´æ˜ï¼šåç«¯ä½¿ç”¨ JWTï¼ˆæˆ– Surreal SCOPE tokenï¼‰ä¸ºä¸»ï¼›
# WebSocket åœ¨æ¡æ‰‹æ—¶é€šè¿‡ Header æ‰¿è½½ï¼Œä¸å†åœ¨æ¶ˆæ¯ä½“é‡Œä¼  api_key/user_id

[performance]
read_replica_count = 3
connection_pool_size = 50
query_timeout_ms = 5000

[monitoring]
metrics_enabled = true
prometheus_endpoint = "/metrics"
health_check_interval = 30
```

### 3. Docker Compose è®¾ç½®

```yaml
# docker-compose.yml
version: '3.8'

services:
  surrealdb:
    image: surrealdb/surrealdb:latest
    command: start --log trace --user root --pass root memory
    ports:
      - "8000:8000"
    volumes:
      - surrealdb_data:/data
    environment:
      - SURREAL_LOG=trace
      - SURREAL_USER=root
      - SURREAL_PASS=root

  soulbox:
    build: .
    ports:
      - "3000:3000"
    environment:
      - DATABASE_HOST=surrealdb
      - DATABASE_PORT=8000
      - DATABASE_NS=soulbox_dev
      - DATABASE_DB=main
      - DATABASE_USER=root
      - DATABASE_PASS=root
    depends_on:
      - surrealdb

volumes:
  surrealdb_data:
```

## ğŸ§ª æµ‹è¯•ç­–ç•¥

### 1. å•å…ƒæµ‹è¯•

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use tokio_test;

    #[tokio::test]
    async fn test_user_creation() {
        let db_manager = create_test_database().await;
        let user_repo = SurrealUserRepository::new(&db_manager);

        let user = User {
            id: None,
            email: "test@example.com".to_string(),
            username: "testuser".to_string(),
            password_hash: "hashed_password".to_string(),
            created_at: Utc::now(),
            last_login: None,
            subscription_tier: "free".to_string(),
            is_active: true,
            metadata: serde_json::Value::Null,
        };

        let created_user = user_repo.create_user(&user).await.unwrap();
        assert!(created_user.id.is_some());
        assert_eq!(created_user.email, user.email);
    }

    #[tokio::test]
    async fn test_live_query_monitoring() {
        let db_manager = create_test_database().await;
        let monitor = RealtimeMonitor::new(&db_manager);

        // æµ‹è¯•å®æ—¶æŸ¥è¯¢åŠŸèƒ½
        // è¿™é€šå¸¸æ¶‰åŠåˆ›å»ºæµ‹è¯•æ•°æ®å’Œç›‘æ§å˜åŒ–
    }

    async fn create_test_database() -> DatabaseManager {
        let config = DatabaseConfig {
            host: "127.0.0.1".to_string(),
            port: 8000,
            namespace: "test".to_string(),
            database: format!("test_{}", uuid::Uuid::new_v4()),
            username: "root".to_string(),
            password: "root".to_string(),
        };

        DatabaseManager::new(config).await.unwrap()
    }
}
```

### 2. é›†æˆæµ‹è¯•

```rust
#[cfg(test)]
mod integration_tests {
    use super::*;

    #[tokio::test]
    async fn test_full_execution_workflow() {
        let db_manager = create_test_database().await;
        
        // åˆ›å»ºç”¨æˆ·
        let user_repo = SurrealUserRepository::new(&db_manager);
        let user = create_test_user().await;
        let created_user = user_repo.create_user(&user).await.unwrap();

        // åˆ›å»ºæ²™ç®±
        let sandbox_repo = SurrealSandboxRepository::new(&db_manager);
        let sandbox = create_test_sandbox(&created_user.id.unwrap()).await;
        let created_sandbox = sandbox_repo.create_sandbox(&sandbox).await.unwrap();

        // åˆ›å»ºæ‰§è¡Œ
        let execution_repo = SurrealExecutionRepository::new(&db_manager);
        let execution = create_test_execution(&created_sandbox.id.unwrap(), &created_user.id.unwrap()).await;
        let created_execution = execution_repo.create_execution(&execution).await.unwrap();

        // éªŒè¯å…³ç³»
        let user_sandboxes = sandbox_repo.get_user_sandboxes(&created_user.id.unwrap()).await.unwrap();
        assert_eq!(user_sandboxes.len(), 1);

        let sandbox_executions = execution_repo.get_sandbox_executions(&created_sandbox.id.unwrap()).await.unwrap();
        assert_eq!(sandbox_executions.len(), 1);
    }
}
```

---

è¿™ä»½å…¨é¢çš„ SurrealDB é›†æˆæŒ‡å—ä¸º SoulBox æä¾›äº†ç°ä»£åŒ–çš„é«˜æ€§èƒ½æ•°æ®åº“è§£å†³æ–¹æ¡ˆï¼Œæ¶ˆé™¤äº†ç®¡ç†å¤šç§æ•°æ®åº“æŠ€æœ¯çš„å¤æ‚æ€§ï¼ŒåŒæ—¶æä¾›äº†ä¼˜è¶Šçš„å®æ—¶èƒ½åŠ›ã€çµæ´»çš„æ•°æ®å»ºæ¨¡å’Œå‡ºè‰²çš„ Rust é›†æˆã€‚